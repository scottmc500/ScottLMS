name: Production Deployment

on:
  push:
    branches: [ main ]
  workflow_dispatch: # Allow manual triggering
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging
      skip_infrastructure:
        description: 'Skip infrastructure deployment'
        required: false
        default: false
        type: boolean

env:
  AWS_REGION: us-west-2
  PROJECT_NAME: scottlms
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-west-2.amazonaws.com
  ECR_REPOSITORY: scottlms-api

jobs:
  # Pre-deployment checks
  pre-deploy-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      image-tag: ${{ steps.set-env.outputs.image-tag }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set environment variables
      id: set-env
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
        else
          echo "environment=production" >> $GITHUB_OUTPUT
        fi
        
        # Generate image tag
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "image-tag=manual-$(date +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT
        else
          echo "image-tag=${{ github.sha }}" >> $GITHUB_OUTPUT
        fi

    - name: Validate environment
      run: |
        echo "Deploying to: ${{ steps.set-env.outputs.environment }}"
        echo "Image tag: ${{ steps.set-env.outputs.image-tag }}"

  # Infrastructure deployment
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: pre-deploy-checks
    if: ${{ !github.event.inputs.skip_infrastructure }}
    environment: ${{ needs.pre-deploy-checks.outputs.environment }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: 1.6.0

    - name: Terraform Init
      run: |
        cd terraform
        terraform init

    - name: Terraform Plan
      run: |
        cd terraform
        terraform plan \
          -var="environment=${{ needs.pre-deploy-checks.outputs.environment }}" \
          -var="project_name=${{ env.PROJECT_NAME }}" \
          -var="mongodb_atlas_public_key=${{ secrets.MONGODB_ATLAS_PUBLIC_KEY }}" \
          -var="mongodb_atlas_private_key=${{ secrets.MONGODB_ATLAS_PRIVATE_KEY }}" \
          -var="mongodb_atlas_project_id=${{ secrets.MONGODB_ATLAS_PROJECT_ID }}" \
          -out=tfplan

    - name: Terraform Apply
      run: |
        cd terraform
        terraform apply tfplan

    - name: Get ECR repository URL
      id: ecr-url
      run: |
        ECR_URL=$(aws ecr describe-repositories --repository-names "${{ env.ECR_REPOSITORY }}" --region ${{ env.AWS_REGION }} --query 'repositories[0].repositoryUri' --output text)
        echo "ecr-url=$ECR_URL" >> $GITHUB_OUTPUT

  # Build and push Docker image
  build-and-push:
    name: Build and Push Image
    runs-on: ubuntu-latest
    needs: [pre-deploy-checks, deploy-infrastructure]
    if: always() && (needs.deploy-infrastructure.result == 'success' || needs.deploy-infrastructure.result == 'skipped')

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Get ECR repository URL
      id: ecr-url
      run: |
        ECR_URL=$(aws ecr describe-repositories --repository-names "${{ env.ECR_REPOSITORY }}" --region ${{ env.AWS_REGION }} --query 'repositories[0].repositoryUri' --output text)
        echo "ecr-url=$ECR_URL" >> $GITHUB_OUTPUT

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ env.ECR_REPOSITORY }}
        IMAGE_TAG: ${{ needs.pre-deploy-checks.outputs.image-tag }}
      run: |
        # Build a docker container and push it to ECR
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

    - name: Update Kubernetes manifests with new image
      run: |
        # Update the image tag in the deployment manifest
        sed -i "s|scottlms-api:latest|${{ steps.build-image.outputs.image }}|g" k8s/deployment.yaml
        
        # Update the image tag in kustomization.yaml
        sed -i "s|newTag: latest|newTag: ${{ needs.pre-deploy-checks.outputs.image-tag }}|g" k8s/kustomization.yaml

    - name: Upload updated manifests
      uses: actions/upload-artifact@v3
      with:
        name: k8s-manifests
        path: k8s/

  # Deploy to Kubernetes
  deploy-application:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: [pre-deploy-checks, build-and-push]
    environment: ${{ needs.pre-deploy-checks.outputs.environment }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Download updated manifests
      uses: actions/download-artifact@v3
      with:
        name: k8s-manifests

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.PROJECT_NAME }}-${{ needs.pre-deploy-checks.outputs.environment }}

    - name: Create namespace if it doesn't exist
      run: |
        kubectl create namespace scottlms --dry-run=client -o yaml | kubectl apply -f -

    - name: Deploy to Kubernetes
      run: |
        # Apply all Kubernetes manifests
        kubectl apply -k k8s/
        
        # Wait for deployment to be ready
        kubectl wait --for=condition=available --timeout=600s deployment/scottlms-api -n scottlms

    - name: Verify deployment
      run: |
        # Check pod status
        kubectl get pods -n scottlms
        
        # Check service status
        kubectl get services -n scottlms
        
        # Check ingress status
        kubectl get ingress -n scottlms

    - name: Run health check
      run: |
        # Port forward to test the application
        kubectl port-forward service/scottlms-api-service 8080:80 -n scottlms &
        PF_PID=$!
        
        # Wait for port forward to be ready
        sleep 10
        
        # Test health endpoint
        curl -f http://localhost:8080/health || exit 1
        
        # Clean up port forward
        kill $PF_PID

  # Post-deployment tests
  post-deploy-tests:
    name: Post-deployment Tests
    runs-on: ubuntu-latest
    needs: [pre-deploy-checks, deploy-application]
    environment: ${{ needs.pre-deploy-checks.outputs.environment }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.PROJECT_NAME }}-${{ needs.pre-deploy-checks.outputs.environment }}

    - name: Get application URL
      id: app-url
      run: |
        # Get the ALB DNS name from Terraform output
        ALB_DNS=$(cd terraform && terraform output -raw alb_dns_name 2>/dev/null || echo "")
        if [ -n "$ALB_DNS" ]; then
          echo "app-url=https://$ALB_DNS" >> $GITHUB_OUTPUT
        else
          # Fallback to port-forward for testing
          echo "app-url=http://localhost:8080" >> $GITHUB_OUTPUT
        fi

    - name: Run smoke tests
      run: |
        if [[ "${{ steps.app-url.outputs.app-url }}" == "http://localhost:8080" ]]; then
          # Use port forward for testing
          kubectl port-forward service/scottlms-api-service 8080:80 -n scottlms &
          PF_PID=$!
          sleep 10
          APP_URL="http://localhost:8080"
        else
          APP_URL="${{ steps.app-url.outputs.app-url }}"
        fi
        
        # Test health endpoint
        curl -f "$APP_URL/health" || exit 1
        
        # Test API documentation
        curl -f "$APP_URL/docs" || exit 1
        
        # Test root endpoint
        curl -f "$APP_URL/" || exit 1
        
        if [[ "${{ steps.app-url.outputs.app-url }}" == "http://localhost:8080" ]]; then
          kill $PF_PID
        fi

    - name: Run load test
      run: |
        # Install k6
        sudo gpg -k
        sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
        echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
        sudo apt-get update
        sudo apt-get install k6

        # Create load test
        cat > load-test.js << 'EOF'
        import http from 'k6/http';
        import { check, sleep } from 'k6';

        export let options = {
          vus: 10,
          duration: '1m',
        };

        export default function () {
          let response = http.get('${{ steps.app-url.outputs.app-url }}/health');
          check(response, {
            'status is 200': (r) => r.status === 200,
            'response time < 1000ms': (r) => r.timings.duration < 1000,
          });
          sleep(1);
        }
        EOF
        
        k6 run load-test.js

  # Notification
  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [pre-deploy-checks, deploy-infrastructure, build-and-push, deploy-application, post-deploy-tests]
    if: always()

    steps:
    - name: Deployment Summary
      run: |
        echo "## 🚀 Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Environment:** ${{ needs.pre-deploy-checks.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
        echo "**Image Tag:** ${{ needs.pre-deploy-checks.outputs.image-tag }}" >> $GITHUB_STEP_SUMMARY
        echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Step | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|------|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| Infrastructure | ${{ needs.deploy-infrastructure.result == 'success' && '✅' || needs.deploy-infrastructure.result == 'skipped' && '⏭️' || '❌' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Build & Push | ${{ needs.build-and-push.result == 'success' && '✅' || '❌' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Deploy Application | ${{ needs.deploy-application.result == 'success' && '✅' || '❌' }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Post-deploy Tests | ${{ needs.post-deploy-tests.result == 'success' && '✅' || '❌' }} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ needs.deploy-application.result }}" = "success" ]; then
          echo "### 🎉 Deployment Successful!" >> $GITHUB_STEP_SUMMARY
          echo "Your application has been successfully deployed to ${{ needs.pre-deploy-checks.outputs.environment }}." >> $GITHUB_STEP_SUMMARY
        else
          echo "### ❌ Deployment Failed" >> $GITHUB_STEP_SUMMARY
          echo "Please check the logs for more details." >> $GITHUB_STEP_SUMMARY
        fi

    - name: Slack Notification (if configured)
      if: always() && env.SLACK_WEBHOOK_URL != ''
      uses: 8398a7/action-slack@v3
      with:
        status: ${{ job.status }}
        channel: '#deployments'
        text: |
          ScottLMS Deployment ${{ job.status == 'success' && '✅ Successful' || '❌ Failed' }}
          Environment: ${{ needs.pre-deploy-checks.outputs.environment }}
          Commit: ${{ github.sha }}
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
